* q1
  ``` js
  var a = [];
  for(var i = 0;i<10;i++ {
      a[i] = function() {
          console.log(i);
      }
  }>);
  a[6]();
  ```
* ans1<br>
  运行结果为`10`<br>因为外层声明的`i`是使用var声明的，那么它不是一个块级作用域的成员，因此是全局的数据成员，因此最后引用到全局全局作用域中的`i`，因此这个`i`在循环结束之后是10，因此不管是哪个下标打印的数据都是`10`。

***
* q2 
``` js
var temp = 123;
if(true) {
    console.log(temp);
    let temp;
}
```
* ans2<br>
  运行报错，由于let的存在，因此在if这个块级作用域中，输出的temp是由let定义的temp，而temp的定义在console的下一句，因此会报错。
***
* q3
```js
//ans3
var arr = [12,34,32,89,4];
var minNum = Math.min(...arr);
console.log(minNum)
//console.log（4）
```
***
* q4
* ans4<br>
```js
// var
// 1、定义的变量为全局作用域，同名变量会相互覆盖
// 2、定义内容可以修改
// 3、定义的变量不初始化会输出undefined
var a = 1
console.log(a) //a的值为1
var b
console.log(b) //如果b不赋值则输出undefined
// let
// 1、定义的变量为块级作用域，不同的作用域之间同名变量不会相互影响，同一个作用域中不能定义同名let变量，定义的变量只在当前作用域生效。
// 2、定义内容可以修改
// 3、定义的变量不初始化会输出undefined
function test () {
    for (let i=1;i<3;i++) { // let只在当前作用域内部生效
        console.log(i)    // 输出1、2
    }
    console.log(i)    // i is not defined
}
//const 
// 1、主要用于申明常量，无法被修改,它也是块级作用域变量。
// 2、const定义的常量必须初始化
// 3、但是const如果定义为一个对象，这个对象是可以修改的,类似于一个指针常量，既无法改变这个CONST指向的对象，但是这个对象的值可以改变
function test () {
    const a = 6
    a = 8 // 报错.
}
```
  
  
***
* q5
```js
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    }, 0);
  },
};
obj.fn();
```
* ans5<br>
  `20`，箭头函数不会改变`this`的指向，因此使用箭头函数调用方法，则`this`一直会是定义时的`this`，因此这个函数可以获取到的`this`指向的`OBJ`,因此可以访问到`obj.a=20`.

***

* q6<br>
  `symbol`是一个新类型，它的特点是每一个创建的值都是唯一的，他也可以作为对象的成员，因此我们可以避免对象属性名重复的问题，这样子就可以不用担心由于各种问题导致的属性名重复的问题。其次就是可以通过`symbol`的唯一性，可以用来实现类的私有数据，而不用通过约定。

***
* q7<br>
  深拷贝和浅拷贝的区别就是，假设B复制了A，当修改A时，如果B也跟着变了，说明这是浅拷贝如果B没变，那就是深拷贝。这是由于数据的类型有基础数据类型和引用数据类型。直接使用赋值的方式进行拷贝的时候，引用数据类型拷贝到的实际上是对这个数据的应用，相当于将B指向了A所指向的区域，而深拷贝则是重新分配了一块内存并且让B指向这个新的内存，这个内存里面保存的数据和A指向的区域保存的数据一样。

***
* q8<br>
  `typescript`是`javascript`的超集，相当于是以`javascript`为基础，增加了更强大的类型系统和对es规范的支持。实际上就是以面向对象编程的方式使用`Javascript`。当然最后代码还是编译为`Javascript`。

***

* q9<br>
`typescript`相对于原生的`javascript`会更加厚重，增加了很多新的概念，例如泛型编程，枚举，接口等这些常见于各类面向对象语言的概念，而对于小型项目而言，会增加项目开发的成本，如学习成本等。但是它的兼容性非常的好，由于最后都会编译为原生的JavaScript，因此兼容性的问题会更低，而它是一个完整的语言，功能会更加强大，在JavaScript的基础之上增加了更强大的类型系统和对ES规范的支持，这样也会使得开发复杂项目更加的容易，相比起原来的原生开发方式也更能够提高代码的质量。使得开发过程中既能有面向对象语言的严谨，最后运行起来还是和之前的原生JS一样兼容并包。

***
* q10<br>
引用计数算法的原理就是对每个内存使用设置引用数，当引用数为0的时候，那么GC可以开始工作可以回收这个内存区域并释放出来。当某个对象的引用关系发生了变化，就可以改变这个对象的引用数。引用计数算法会在发现引用为0时立刻回收，因此可以最大限度的减少整个程序暂停的时间。但是缺点在于没法处理循环引用的对象，同时由于要监控引用计数，因此相对来说更加耗费时间。
    ```js
    //循环引用
    const obj1 = {}；
    const obj2 = {};
    obj1.pre = obj2;
    obj2.nxt = obj1;
    ```
***
* q11<br>
  标记清除算法的工作流程是分标记和清除两个步骤，先遍历所有对象对进行标记，然后再遍历一遍清除所有不是活动的对象。然后就回收了所有的空间，将他们放到空闲列表中。相对于引用计数算法，它可以处理循环引用的对象，但是缺点就是，容易造成碎片化的空间，导致内存的使用并不能非常的有效率。


***
* q12<br>
  V8内部，将内存空间分成两个部分，新生代区域和老生代区域，新生代对象指的是存活时间较短的对象，例如局部变量。新生代区域的内存管理主要通过复制算法和标记整理算法来实现，首先会吧内存分为两个相等的空间，分为活动空间（from）和空闲空间（to），当触发GC时，使用标记整理算法将活动空间中的对象进行标记，然后将再使用复制算法将活动对象复制到空闲空间中，然后再释放掉原来空间中的所有对象，这样就可以获得大量连续的可用空间， 避免了释放内存后的空间碎片化。而这时空闲空间和活动空间则相当于互换了。拷贝过程中，有可能会将新生代转换为老生代对象，会将它们拷贝到老生代储存区。这些转换会发生在TO空间使用过多，或者当一轮GC之后还有存活的新生代对象时发生。

***
* q13<br>
标记增量算法将我们当前的垃圾回收操作拆分为几个小的步骤，组合起来完成整个垃圾回收操作，让垃圾回收和程序执行交替进行。在程序执行过程中，我们可以执行一段，然后进行一段标记，然后以此类推，当所有标记操作都执行完毕之后，我们再进行一次回收内存的操作，这样拆分了回收的时间，让整个程序流畅度度都上升了。标记增量算法优化了整体的垃圾回收机制，在V8引擎中的老生代区域中，会使用这个算法优化整个垃圾回收操作。

  
